libname IPEDS '~/IPEDS';
options fmtsearch = (IPEDS);

*1.7 Activities Continued; 

proc sql;
	create table ex5 as
	select stock, year(date) as year,
		mean(high) as HighMean format=dollar8.2,
		mean(low) as LowMean format=dollar8.2,
		calculated HighMean - calculated LowMean as MeanDiff 
				format=dollar12.2	
	from sashelp.stocks 
	where year(date) between 2000 and 2005
	group by stock, Year
	having meanDiff gt 10
;
quit;

proc sql;
*	create table ex5v2 as
	select stock, year(date) as year,
		mean(high) as HighMean format=dollar8.2,
		mean(low) as LowMean format=dollar8.2,
		calculated HighMean - calculated LowMean as MeanDiff 
				format=dollar12.2	
	from sashelp.stocks 
	where year(date) between 2000 and 2005
		and calculated meanDff gt 10
			/*can't be here because meanDiff is derived from summary functions (mean)*/
	group by stock, Year
;
quit;

proc sql;
	create table ex5v3 as
	select stock, year(date) as year,
		mean(high) as HighMean format=dollar8.2,
		mean(low) as LowMean format=dollar8.2,
		calculated HighMean - calculated LowMean as MeanDiff 
				format=dollar12.2	
	from sashelp.stocks 
	group by stock, Year
	having meanDiff gt 10
		and year(date) between 2000 and 2005
			/*goes back to the table and pulls every record that satisfies this and remerges onto the summary*/

; /*the one above is no good, the one below is good, look at second line of have statement*/
	create table ex5v4 as
	select stock, year(date) as year,
		mean(high) as HighMean format=dollar8.2,
		mean(low) as LowMean format=dollar8.2,
		calculated HighMean - calculated LowMean as MeanDiff 
				format=dollar12.2	
	from sashelp.stocks 
	group by stock, Year
	having meanDiff gt 10
		and year between 2000 and 2005
		/*this uses the variables constructed and puts into group, and subsets from there*/

; /*still good just different method*/
	create table ex5v5 as
	select stock, year(date) as year,
		mean(high) as HighMean format=dollar8.2,
		mean(low) as LowMean format=dollar8.2,
		calculated HighMean - calculated LowMean as MeanDiff 
				format=dollar12.2	
	from sashelp.stocks 
	where calculated year between 2000 and 2005
	group by stock, Year
	having meanDiff gt 10
;
quit;

/*Combining Tables in SQL*/

proc sql;

	select ch.unitID label='ID from Char.',
			gr.unitID label='ID from Grad.',
			ch.control, gr.total 

	from ipeds.Characteristics(obs=3) as ch, 
			ipeds.Graduation(obs=2) as gr 
			/*If you list multiple tables in the FROM clause (comma seperated) with no other instructions. 
				you get a Cartesian product of the records*/

	where group contains 'Incoming'
; /*no subsetting here*/
quit; 


proc sql;
create table Inner1 as
			/*make sure you prefix everyy variable with the alias anywhere you use it*/
	select ch.unitID label='Inst. ID', 
			instnm, total, group

	from ipeds.Characteristics as ch inner join ipeds.Graduation as gr
		on gr.unitID eq ch.unitID
			/*Inner Join keeps rows generated by matches corresponding to the on criterion*/
;
quit;

proc sql;
create table Inner2 as

	select ch.unitID label='Inst. ID', 
			instnm, total, group
	
	from ipeds.Characteristics as ch,
			 ipeds.graduation as gr
		/*A comma separated list of tables generates a Cartesian product...*/

	where gr.unitID eq ch.unitID 
		/*... but a where condition can limit it to matches*/
;
quit;

proc sql; /*easier way to do multiple joins this one*/
create table multipleJoin as
	select ch.unitID label='Inst. ID', instnm, total, group,
			tuition2 label='In State' format=comma9.,
			tuition3 label='Out of State' format=comma9.

	from ipeds.Characteristics as ch,
			ipeds.Graduation as gr,
			ipeds.TuitionAndCosts as tc 

	where gr.unitID eq ch.unitID eq tc.unitID 
;
quit;

proc sql; /*still multiple joins, but a longer more difficult way to do it, does have its bennefits*/
create table multipleJoin2 as

	select ch.unitID label='Inst. ID', instnm, total, group,
			tuition2 label='In State' format=comma9.,
			tuition3 label='Out of State' format=comma9.

	from (ipeds.Characteristics as ch inner join ipeds.Graduation as gr
			on gr.unitID eq ch.unitID) /*we do an inner join of two tables*/
			inner join ipeds.TuitionAndCosts as tc
			on ch.unitID eq tc.unitID /*joining the result to the other one*/ 
;
create table multipleJoin3 as

	select ch.unitID label='Inst. ID', instnm, total, group,
			tuition2 label='In State' format=comma9.,
			tuition3 label='Out of State' format=comma9.

	from (ipeds.Characteristics as ch inner join ipeds.Graduation as gr
			on gr.unitID eq ch.unitID)
			inner join ipeds.TuitionAndCosts as tc
			on ch.unitID eq tc.unitID
	
	where tuition3 ge 15000 and group contains 'Incoming' 
		/*Now a subsetting WHERE can be separated from a row matching condition*/
;
quit;

*Program 2.3.5: An Inner Join in a More Complex Request;

proc sql; /*can do joins and summary functions at the same time*/
create table avgTuition as

	select control,
		mean(tuition2) label='Avg. In-State Tuition' format=dollar12.2 as AvgInState,
		mean(tuition3) label='Avg. Out-of-State Tuition' format=dollar12.2 as AvgOutState,
		calculated AvgOutState - calculated AvgInState format=dollar12.2
		label='Avg. Difference' as AvgDiff,
		mean(tuition3/tuition2 gt 2) label='Proportion with Out:In State at least 2' format=percent8.1 as HighOOS 

	from ipeds.Characteristics as ch inner join ipeds.TuitionAndCosts as tc
		on ch.unitID eq tc.unitID 

	where tuition3 gt tuition2 and tuition2 gt 0 and control gt 0 

	group by control
;
quit;

*Program 2.3.6: Inner Joins Across Three Tables with Different Matching Criteria;

proc sql;
create table anotherjoin as

	select ch.instnm, ch.Control, total, AvgOutState

	from (ipeds.Characteristics as ch inner join ipeds.Graduation as gr
			on ch.unitid eq gr.unitid) 
		inner join avgTuition as avT  on avT.Control eq ch.Control 
			/*cannot join on an alias of a join*/

	where group contains 'Incoming' and total ge 450 

	order by total
;
quit;

proc sql;
create table anotherjoinB as

	select ch.instnm, ch.Control, total, AvgOutState

	from ipeds.Characteristics as ch, ipeds.Graduation as gr,
		avgTuition as avT

	where ch.unitid eq gr.unitid and avT.Control eq ch.Control
		and group contains 'Incoming' and total ge 450 
	
	order by total
;
quit;

*Many-to-many join;

proc sql;
	select avTA.Control label='Control A', avTA.AvgInState as A,
			avTB.Control label='Control B', avTB.AvgInState as B,
			A-B label='Difference (A-B)' format=dollar12.2

	from avgTuition as avTA inner join avgTuition as avTB 
		on avTA.Control ne avTB.Control 
;
	select avTA.Control label='Control A', avTA.AvgInState as A,
			avTB.Control label='Control B', avTB.AvgInState as B,
			A-B label='Difference (A-B)' format=dollar12.2

	from avgTuition as avTA inner join avgTuition as avTB 
		on avTA.Control lt avTB.Control 
;
	select avTA.Control label='Control A', avTA.AvgInState as A,
			avTB.Control label='Control B', avTB.AvgInState as B,
			A-B label='Difference (A-B)' as Diff format=dollar12.2

	from avgTuition as avTA inner join avgTuition as avTB 
		on avTA.Control ne avTB.Control 

	where calculated Diff ge 0

	order by Diff desc
;
quit;

*Full Join;

libname SASData '~/SASData';

proc sql;
create table FullJoin as 

	select ParkName, ParkCode, Traf2016.* 

	from SASData.np_codeLookUp full join 
		SASData.np_2016Traffic as Traf2016
		on ParkCode eq Code 
/*Full Join is like the data step match merge default logic.. preserve all mismatches and matches*/
;
quit;

proc sql; 
create table FullJoin as 

	select ParkName, ParkCode, Traf2016.* 

	from SASData.np_codeLookUp full join 
		SASData.np_2016Traffic as Traf2016
		on ParkCode eq Code 
;

create table Leftjoin as 

	select ParkName, ParkCode, Traf2016.* 

	from SASData.np_codeLookUp left join 
		SASData.np_2016Traffic as Traf2016
		on ParkCode eq Code 
; /*Left join preserves all records from the "left"/first table...*/

create table RightJoin as 

	select ParkName, ParkCode, Traf2016.* 

	from SASData.np_codeLookUp right join 
		SASData.np_2016Traffic as Traf2016
		on ParkCode eq Code 
; /*Right join keeps all from the "right"/second table*/

create table InnerJoin as 

	select ParkName, ParkCode, Traf2016.* 

	from SASData.np_codeLookUp inner join 
		SASData.np_2016Traffic as Traf2016
		on ParkCode eq Code 
;
quit;


















